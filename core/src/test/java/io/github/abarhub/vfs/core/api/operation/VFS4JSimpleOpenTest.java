package io.github.abarhub.vfs.core.api.operation;

import io.github.abarhub.vfs.core.FsUtils;
import io.github.abarhub.vfs.core.api.VFS4JFileManager;
import io.github.abarhub.vfs.core.api.path.VFS4JPathName;
import io.github.abarhub.vfs.core.api.path.VFS4JPaths;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.channels.SeekableByteChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

class VFS4JSimpleOpenTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(VFS4JSimpleOpenTest.class);
    public static final String PATH1 = "path1";

    private VFS4JFileManager fileManager;

    private Path directory;

    private VFS4JSimpleOpen open;

    @BeforeEach
    void setUp(@TempDir Path tempDir) throws IOException {
        fileManager = new VFS4JFileManager();

        assertTrue(Files.exists(tempDir));
        Path temp = tempDir.resolve("temp");
        assertFalse(Files.exists(temp));
        Files.createDirectory(temp);
        assertTrue(Files.exists(temp));
        assertTrue(Files.isDirectory(temp));
        directory = temp;
        fileManager = new VFS4JFileManager();
        fileManager.getConfig().addPath(PATH1, temp);

        open = new VFS4JSimpleOpen(fileManager);
    }

    @Test
    void newInputStream() throws IOException {

        final String filename = "fichier.txt";
        final Path file = directory.resolve(filename);
        final byte[] buf = "abc123456".getBytes(StandardCharsets.UTF_8);
        Files.write(file, buf);

        // methode testée
        InputStream input = open.newInputStream(getPathName(filename));

        // vérifications
        assertNotNull(input);
        byte[] byteArray = FsUtils.readAll(input);
        assertArrayEquals(buf, byteArray);
    }

    @Test
    void newOutputStream() throws IOException {
        final String filename = "fichier2.txt";
        final byte[] buf = "rtyuio65874".getBytes(StandardCharsets.UTF_8);

        // methode testé
        OutputStream output = open.newOutputStream(getPathName(filename));

        // vérifications
        assertNotNull(output);
        try {
            output.write(buf);
            output.flush();
        } finally {
            output.close();
        }

        byte[] bufRes = Files.readAllBytes(directory.resolve(filename));
        assertArrayEquals(buf, bufRes);
    }

    @Test
    void newReader() throws IOException {
        final String filename = "fichier3.txt";
        final Path file = directory.resolve(filename);
        final String contenu = "abc123def";
        final List<String> liste = FsUtils.newList(contenu);
        Files.write(file, liste);

        // methode testée
        FileReader reader = open.newReader(getPathName(filename));

        // vérifications
        assertNotNull(reader);
        List<String> lignes = FsUtils.readAll(reader);
        assertEquals(liste, lignes);
    }

    @Test
    void newWriter() throws IOException {
        final String filename = "fichier3.txt";
        final Path file = directory.resolve(filename);
        final String contenu = "abc123def";

        // methode testée
        FileWriter writer = open.newWriter(getPathName(filename), false);

        // vérifications
        assertNotNull(writer);
        try (BufferedWriter bufferedWriter = new BufferedWriter(writer)) {
            bufferedWriter.append(contenu);
        }
        List<String> list = Files.readAllLines(file);
        assertNotNull(list);
        assertEquals(1, list.size());
        assertEquals(contenu, list.get(0));
    }

    @Test
    void newByteChannel() throws IOException {
        final String filename = "fichier4.txt";
        final Path file = directory.resolve(filename);
        final String contenu = "abc123defghi";
        final List<String> liste = FsUtils.newList(contenu);
        Files.write(file, liste);
        Set<OpenOption> openOptions = new HashSet<>();
        openOptions.add(StandardOpenOption.READ);

        // methode testée
        try (SeekableByteChannel byteChannel = open.newByteChannel(getPathName(filename), openOptions)) {

            // vérifications
            assertNotNull(byteChannel);
            final String contenuFinal = readAllBuffer(byteChannel);
            assertEquals(contenu + System.lineSeparator(), contenuFinal);
        }
    }

    @Test
    void newDirectoryStream() throws IOException {
        final String dirRoot = "directory";
        final Path dir = directory.resolve(dirRoot);
        Files.createDirectory(dir);
        Set<String> fileList = new HashSet<>();
        fileList.add("fichier1.txt");
        fileList.add("file2.pdf");
        fileList.add("file3.jpg");
        Set<VFS4JPathName> setRef = new HashSet<>();
        for (String filename : fileList) {
            Files.createFile(dir.resolve(filename));
            setRef.add(getPathName(dirRoot + File.separator + filename));
        }

        // methode testée
        try (DirectoryStream<VFS4JPathName> res = open.newDirectoryStream(getPathName(dirRoot), x -> true)) {

            // vérifications
            assertNotNull(res);
            Set<VFS4JPathName> resultat = new HashSet<>();
            Iterator<VFS4JPathName> iter = res.iterator();
            while (iter.hasNext()) {
                resultat.add(iter.next());
            }
            assertEquals(3, resultat.size());
            assertEquals(setRef, resultat);
        }
    }

    // methodes utilitaires

    public VFS4JPathName getPathName(String filename) {
        return VFS4JPaths.get(PATH1, filename);
    }

    private String readAllBuffer(SeekableByteChannel byteChannel) throws IOException {
        ByteBuffer byteBuffer = ByteBuffer.allocate(10);
        StringBuilder stringBuilder = new StringBuilder();
        while (byteChannel.read(byteBuffer) > 0) {
            byteBuffer.flip();
            while (byteBuffer.hasRemaining()) {
                stringBuilder.append((char) byteBuffer.get());
            }
            byteBuffer.clear();
        }

        final String contenuFinal = stringBuilder.toString();
        return contenuFinal;
    }
}