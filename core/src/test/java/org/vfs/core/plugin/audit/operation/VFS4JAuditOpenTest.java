package org.vfs.core.plugin.audit.operation;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.vfs.core.api.VFS4JPathName;
import org.vfs.core.api.operation.VFS4JOpen;
import org.vfs.core.config.VFS4JConfig;
import org.vfs.core.plugin.audit.VFS4JAuditLogLevel;
import org.vfs.core.plugin.audit.VFS4JAuditOperation;
import org.vfs.core.plugin.audit.VFS4JAuditPlugins;
import org.vfs.core.plugin.audit.VFS4JLogAudit;

import java.io.*;
import java.nio.channels.SeekableByteChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.DirectoryStream;
import java.nio.file.OpenOption;
import java.nio.file.StandardOpenOption;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class VFS4JAuditOpenTest implements VFS4JLogAudit {

    private static final Logger LOGGER = LoggerFactory.getLogger(VFS4JAuditOpenTest.class);

    public static final String PATH1 = "path1";

    private VFS4JAuditPlugins vfs4JAuditPlugins;

    private final VFS4JOpen open = mock(VFS4JOpen.class);

    private VFS4JAuditOpen auditOpen;

    private final List<LogMessage> listLog = new ArrayList<>();

    @BeforeEach
    void setUp() {
        LOGGER.info("setUp");
        vfs4JAuditPlugins = new VFS4JAuditPlugins();
        vfs4JAuditPlugins.addListener(this);
        Map<String, String> config = defautConfig();
        VFS4JConfig config2 = new VFS4JConfig();
        vfs4JAuditPlugins.init("exemple1", config, config2);
        auditOpen = new VFS4JAuditOpen(vfs4JAuditPlugins, open);
    }

    @AfterEach
    void tearDown() {
    }

    @Test
    @DisplayName("Test newInputStream cas nominal")
    void newInputStreamOK() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        InputStream in = new ByteArrayInputStream("abc".getBytes(StandardCharsets.UTF_8));
        when(open.newInputStream(VFS4JPathName)).thenReturn(in);

        // methode testée
        InputStream res = auditOpen.newInputStream(VFS4JPathName);

        // vérifications
        assertNotNull(res);
        assertEquals(in, res);
        verify(open).newInputStream(VFS4JPathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newInputStream for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newInputStream sur un fichier non audit")
    void newInputStreamDisabledFilePattern() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.jpg");
        InputStream in = new ByteArrayInputStream("abc".getBytes(StandardCharsets.UTF_8));
        when(open.newInputStream(VFS4JPathName)).thenReturn(in);

        // methode testée
        InputStream res = auditOpen.newInputStream(VFS4JPathName);

        // vérifications
        assertNotNull(res);
        assertEquals(in, res);
        verify(open).newInputStream(VFS4JPathName);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newInputStream avec audit sur newInputStream désactivé")
    void newInputStreamDisabledAuditnewInputStream() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        InputStream in = new ByteArrayInputStream("abc".getBytes(StandardCharsets.UTF_8));
        when(open.newInputStream(VFS4JPathName)).thenReturn(in);
        Map<String, String> config = defautConfig();
        config.put("operations", VFS4JAuditOperation.COPY.name());
        VFS4JConfig config2 = new VFS4JConfig();
        vfs4JAuditPlugins.init("exemple1", config, config2);

        // methode testée
        InputStream res = auditOpen.newInputStream(VFS4JPathName);

        // vérifications
        assertNotNull(res);
        assertEquals(in, res);
        verify(open).newInputStream(VFS4JPathName);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newInputStream cas exception")
    void newInputStreamErreurKO() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        when(open.newInputStream(VFS4JPathName)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class, () -> auditOpen.newInputStream(VFS4JPathName));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newInputStream(VFS4JPathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newInputStream for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    @Test
    @DisplayName("Test newOutputStream cas nominal")
    void newOutputStreamOK() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        OutputStream out = new ByteArrayOutputStream();
        when(open.newOutputStream(VFS4JPathName)).thenReturn(out);

        // methode testée
        OutputStream res = auditOpen.newOutputStream(VFS4JPathName);

        // vérifications
        assertNotNull(res);
        assertEquals(out, res);
        verify(open).newOutputStream(VFS4JPathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newOutputStream for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newOutputStream audit désactivé")
    void newOutputStreamDisabledFilePattern() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.jpg");
        OutputStream out = new ByteArrayOutputStream();
        when(open.newOutputStream(VFS4JPathName)).thenReturn(out);

        // methode testée
        OutputStream res = auditOpen.newOutputStream(VFS4JPathName);

        // vérifications
        assertNotNull(res);
        assertEquals(out, res);
        verify(open).newOutputStream(VFS4JPathName);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newOutputStream cas exception")
    void newOutputStreamErreurKO() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        when(open.newOutputStream(VFS4JPathName)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class, () -> auditOpen.newOutputStream(VFS4JPathName));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newOutputStream(VFS4JPathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newOutputStream for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    @Test
    @DisplayName("Test newReader cas nominal")
    void newReaderOK() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        FileReader reader = mock(FileReader.class);
        when(open.newReader(VFS4JPathName)).thenReturn(reader);

        // methode testée
        Reader res = auditOpen.newReader(VFS4JPathName);

        // vérifications
        assertNotNull(res);
        assertEquals(reader, res);
        verify(open).newReader(VFS4JPathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newReader for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newReader audit désactivé")
    void newReaderDisabledFilePattern() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.jpg");
        FileReader reader = mock(FileReader.class);
        when(open.newReader(VFS4JPathName)).thenReturn(reader);

        // methode testée
        FileReader res = auditOpen.newReader(VFS4JPathName);

        // vérifications
        assertNotNull(res);
        assertEquals(reader, res);
        verify(open).newReader(VFS4JPathName);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newReader cas exception")
    void newReaderErreurKO() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        when(open.newReader(VFS4JPathName)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class, () -> auditOpen.newReader(VFS4JPathName));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newReader(VFS4JPathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newReader for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    @Test
    @DisplayName("Test newWriter cas nominal")
    void newWriterOK() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        FileWriter writer = mock(FileWriter.class);
        when(open.newWriter(eq(VFS4JPathName), anyBoolean())).thenReturn(writer);

        // methode testée
        FileWriter res = auditOpen.newWriter(VFS4JPathName, true);

        // vérifications
        assertNotNull(res);
        assertEquals(writer, res);
        verify(open).newWriter(VFS4JPathName, true);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newWriter for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newWriter audit désactivé")
    void newWriterDisabledFilePattern() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.jpg");
        FileWriter writer = mock(FileWriter.class);
        when(open.newWriter(VFS4JPathName, true)).thenReturn(writer);

        // methode testée
        FileWriter res = auditOpen.newWriter(VFS4JPathName, true);

        // vérifications
        assertNotNull(res);
        assertEquals(writer, res);
        verify(open).newWriter(VFS4JPathName, true);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newWriter cas exception")
    void newWriterErreurKO() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        when(open.newWriter(VFS4JPathName, true)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class, () -> auditOpen.newWriter(VFS4JPathName, true));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newWriter(VFS4JPathName, true);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newWriter for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    @Test
    @DisplayName("Test newByteChannel cas nominal")
    void newByteChannelOK() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        SeekableByteChannel seekableByteChannel = mock(SeekableByteChannel.class);
        when(open.newByteChannel(VFS4JPathName, getSetOpenOption())).thenReturn(seekableByteChannel);

        // methode testée
        SeekableByteChannel res = auditOpen.newByteChannel(VFS4JPathName, getSetOpenOption());

        // vérifications
        assertNotNull(res);
        assertEquals(seekableByteChannel, res);
        verify(open).newByteChannel(VFS4JPathName, getSetOpenOption());
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newByteChannel for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newByteChannel audit désactivé")
    void newByteChannelDisabledFilePattern() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.jpg");
        SeekableByteChannel seekableByteChannel = mock(SeekableByteChannel.class);
        when(open.newByteChannel(VFS4JPathName, getSetOpenOption())).thenReturn(seekableByteChannel);

        // methode testée
        SeekableByteChannel res = auditOpen.newByteChannel(VFS4JPathName, getSetOpenOption());

        // vérifications
        assertNotNull(res);
        assertEquals(seekableByteChannel, res);
        verify(open).newByteChannel(VFS4JPathName, getSetOpenOption());
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newByteChannel cas exception")
    void newByteChannelErreurKO() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        when(open.newByteChannel(VFS4JPathName, getSetOpenOption())).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class,
                () -> auditOpen.newByteChannel(VFS4JPathName, getSetOpenOption()));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newByteChannel(VFS4JPathName, getSetOpenOption());
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newByteChannel for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    @Test
    @DisplayName("Test newDirectoryStream cas nominal")
    void newDirectoryStreamOK() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        DirectoryStream<VFS4JPathName> directoryStream = getMockDirectoryStream();
        DirectoryStream.Filter<VFS4JPathName> filter = getMockFilter();
        when(open.newDirectoryStream(VFS4JPathName, filter)).thenReturn(directoryStream);

        // methode testée
        DirectoryStream<VFS4JPathName> res = auditOpen.newDirectoryStream(VFS4JPathName, filter);

        // vérifications
        assertNotNull(res);
        assertEquals(directoryStream, res);
        verify(open).newDirectoryStream(VFS4JPathName, filter);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newDirectoryStream for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newDirectoryStream audit désactivé")
    void newDirectoryStreamDisabledFilePattern() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.jpg");
        DirectoryStream<VFS4JPathName> directoryStream = getMockDirectoryStream();
        DirectoryStream.Filter<VFS4JPathName> filter = getMockFilter();
        when(open.newDirectoryStream(VFS4JPathName, filter)).thenReturn(directoryStream);

        // methode testée
        DirectoryStream<VFS4JPathName> res = auditOpen.newDirectoryStream(VFS4JPathName, filter);

        // vérifications
        assertNotNull(res);
        assertEquals(directoryStream, res);
        verify(open).newDirectoryStream(VFS4JPathName, filter);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newDirectoryStream cas exception")
    void newDirectoryStreamErreurKO() throws IOException {
        VFS4JPathName VFS4JPathName = getPathName("abc.txt");
        DirectoryStream.Filter<VFS4JPathName> filter = getMockFilter();
        when(open.newDirectoryStream(VFS4JPathName, filter)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class,
                () -> auditOpen.newDirectoryStream(VFS4JPathName, filter));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newDirectoryStream(VFS4JPathName, filter);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(VFS4JAuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newDirectoryStream for file {}", logMessage.getMessage());
        assertEquals(Collections.singletonList(VFS4JPathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    // methodes utilitaires

    private VFS4JPathName getPathName(String filename) {
        return new VFS4JPathName(PATH1, filename);
    }

    @Override
    public void log(VFS4JAuditLogLevel logLevel, boolean error, String message, Exception exception, Object... parameters) {
        LogMessage logMessage;
        if (parameters != null && parameters.length > 0) {
            logMessage = new LogMessage(logLevel, error, message, Arrays.asList(parameters), exception);
        } else {
            logMessage = new LogMessage(logLevel, error, message, new ArrayList<>(), exception);
        }
        listLog.add(logMessage);
    }

    private Map<String, String> defautConfig() {

        Map<String, String> config = new HashMap<>();
        config.put("loglevel", VFS4JAuditLogLevel.INFO.name());
        config.put("filterPath", "*.txt");
        return config;
    }

    private Set<OpenOption> getSetOpenOption() {
        Set<OpenOption> set = new HashSet<>();
        set.add(StandardOpenOption.READ);
        return set;
    }

    private DirectoryStream<VFS4JPathName> getMockDirectoryStream() {
        return mock(DirectoryStream.class);
    }

    private DirectoryStream.Filter<VFS4JPathName> getMockFilter() {
        return mock(DirectoryStream.Filter.class);
    }

}