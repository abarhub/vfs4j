package org.vfs.core.plugin.audit.operation;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.vfs.core.api.PathName;
import org.vfs.core.api.operation.Open;
import org.vfs.core.config.VFS4JConfig;
import org.vfs.core.plugin.audit.AuditLogLevel;
import org.vfs.core.plugin.audit.AuditOperation;
import org.vfs.core.plugin.audit.VFS4JAuditPlugins;
import org.vfs.core.plugin.audit.VFS4JLogAudit;

import java.io.*;
import java.nio.channels.SeekableByteChannel;
import java.nio.charset.StandardCharsets;
import java.nio.file.DirectoryStream;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class AuditOpenTest implements VFS4JLogAudit {

    private static final Logger LOGGER = LoggerFactory.getLogger(AuditOpenTest.class);

    public static final String PATH1 = "path1";

    private VFS4JAuditPlugins vfs4JAuditPlugins;

    private Open open = mock(Open.class);

    private AuditOpen auditOpen;

    private List<LogMessage> listLog = new ArrayList<>();

    @BeforeEach
    void setUp() {
        vfs4JAuditPlugins = new VFS4JAuditPlugins();
        vfs4JAuditPlugins.addListener(this);
        Map<String, String> config = defautConfig();
        VFS4JConfig config2 = new VFS4JConfig();
        vfs4JAuditPlugins.init("exemple1", config, config2);
        auditOpen = new AuditOpen(vfs4JAuditPlugins, open);
    }

    @AfterEach
    void tearDown() {
    }

    @Test
    @DisplayName("Test newInputStream cas nominal")
    void newInputStreamOK() throws IOException {
        PathName pathName = getPathName("abc.txt");
        InputStream in = new ByteArrayInputStream("abc".getBytes(StandardCharsets.UTF_8));
        when(open.newInputStream(pathName)).thenReturn(in);

        // methode testée
        InputStream res = auditOpen.newInputStream(pathName);

        // vérifications
        assertNotNull(res);
        assertEquals(in, res);
        verify(open).newInputStream(pathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newInputStream for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newInputStream sur un fichier non audit")
    void newInputStreamDisabledFilePattern() throws IOException {
        PathName pathName = getPathName("abc.jpg");
        InputStream in = new ByteArrayInputStream("abc".getBytes(StandardCharsets.UTF_8));
        when(open.newInputStream(pathName)).thenReturn(in);

        // methode testée
        InputStream res = auditOpen.newInputStream(pathName);

        // vérifications
        assertNotNull(res);
        assertEquals(in, res);
        verify(open).newInputStream(pathName);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newInputStream avec audit sur newInputStream désactivé")
    void newInputStreamDisabledAuditnewInputStream() throws IOException {
        PathName pathName = getPathName("abc.txt");
        InputStream in = new ByteArrayInputStream("abc".getBytes(StandardCharsets.UTF_8));
        when(open.newInputStream(pathName)).thenReturn(in);
        Map<String, String> config = defautConfig();
        config.put("operations", AuditOperation.COPY.name());
        VFS4JConfig config2 = new VFS4JConfig();
        vfs4JAuditPlugins.init("exemple1", config, config2);

        // methode testée
        InputStream res = auditOpen.newInputStream(pathName);

        // vérifications
        assertNotNull(res);
        assertEquals(in, res);
        verify(open).newInputStream(pathName);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newInputStream cas exception")
    void newInputStreamErreurKO() throws IOException {
        PathName pathName = getPathName("abc.txt");
        when(open.newInputStream(pathName)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class, () -> auditOpen.newInputStream(pathName));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newInputStream(pathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newInputStream for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    @Test
    @DisplayName("Test newOutputStream cas nominal")
    void newOutputStreamOK() throws IOException {
        PathName pathName = getPathName("abc.txt");
        OutputStream out = new ByteArrayOutputStream();
        when(open.newOutputStream(pathName)).thenReturn(out);

        // methode testée
        OutputStream res = auditOpen.newOutputStream(pathName);

        // vérifications
        assertNotNull(res);
        assertEquals(out, res);
        verify(open).newOutputStream(pathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newOutputStream for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newOutputStream audit désactivé")
    void newOutputStreamDisabledFilePattern() throws IOException {
        PathName pathName = getPathName("abc.jpg");
        OutputStream out = new ByteArrayOutputStream();
        when(open.newOutputStream(pathName)).thenReturn(out);

        // methode testée
        OutputStream res = auditOpen.newOutputStream(pathName);

        // vérifications
        assertNotNull(res);
        assertEquals(out, res);
        verify(open).newOutputStream(pathName);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newOutputStream cas exception")
    void newOutputStreamErreurKO() throws IOException {
        PathName pathName = getPathName("abc.txt");
        when(open.newOutputStream(pathName)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class, () -> auditOpen.newOutputStream(pathName));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newOutputStream(pathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newOutputStream for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    @Test
    @DisplayName("Test newReader cas nominal")
    void newReaderOK() throws IOException {
        PathName pathName = getPathName("abc.txt");
        FileReader reader = mock(FileReader.class);
        when(open.newReader(pathName)).thenReturn(reader);

        // methode testée
        Reader res = auditOpen.newReader(pathName);

        // vérifications
        assertNotNull(res);
        assertEquals(reader, res);
        verify(open).newReader(pathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newReader for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newReader audit désactivé")
    void newReaderDisabledFilePattern() throws IOException {
        PathName pathName = getPathName("abc.jpg");
        FileReader reader = mock(FileReader.class);
        when(open.newReader(pathName)).thenReturn(reader);

        // methode testée
        FileReader res = auditOpen.newReader(pathName);

        // vérifications
        assertNotNull(res);
        assertEquals(reader, res);
        verify(open).newReader(pathName);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newReader cas exception")
    void newReaderErreurKO() throws IOException {
        PathName pathName = getPathName("abc.txt");
        when(open.newReader(pathName)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class, () -> auditOpen.newReader(pathName));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newReader(pathName);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newReader for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    @Test
    @DisplayName("Test newWriter cas nominal")
    void newWriterOK() throws IOException {
        PathName pathName = getPathName("abc.txt");
        FileWriter writer = mock(FileWriter.class);
        when(open.newWriter(eq(pathName), anyBoolean())).thenReturn(writer);

        // methode testée
        FileWriter res = auditOpen.newWriter(pathName, true);

        // vérifications
        assertNotNull(res);
        assertEquals(writer, res);
        verify(open).newWriter(pathName, true);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newWriter for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newWriter audit désactivé")
    void newWriterDisabledFilePattern() throws IOException {
        PathName pathName = getPathName("abc.jpg");
        FileWriter writer = mock(FileWriter.class);
        when(open.newWriter(pathName, true)).thenReturn(writer);

        // methode testée
        FileWriter res = auditOpen.newWriter(pathName, true);

        // vérifications
        assertNotNull(res);
        assertEquals(writer, res);
        verify(open).newWriter(pathName, true);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newWriter cas exception")
    void newWriterErreurKO() throws IOException {
        PathName pathName = getPathName("abc.txt");
        when(open.newWriter(pathName, true)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class, () -> auditOpen.newWriter(pathName, true));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newWriter(pathName, true);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newWriter for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    @Test
    @DisplayName("Test newByteChannel cas nominal")
    void newByteChannelOK() throws IOException {
        PathName pathName = getPathName("abc.txt");
        SeekableByteChannel seekableByteChannel = mock(SeekableByteChannel.class);
        when(open.newByteChannel(pathName, Collections.EMPTY_SET)).thenReturn(seekableByteChannel);

        // methode testée
        SeekableByteChannel res = auditOpen.newByteChannel(pathName, Collections.EMPTY_SET);

        // vérifications
        assertNotNull(res);
        assertEquals(seekableByteChannel, res);
        verify(open).newByteChannel(pathName, Collections.EMPTY_SET);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newByteChannel for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }

    @Test
    @DisplayName("Test newByteChannel audit désactivé")
    void newByteChannelDisabledFilePattern() throws IOException {
        PathName pathName = getPathName("abc.jpg");
        SeekableByteChannel seekableByteChannel = mock(SeekableByteChannel.class);
        when(open.newByteChannel(pathName, Collections.EMPTY_SET)).thenReturn(seekableByteChannel);

        // methode testée
        SeekableByteChannel res = auditOpen.newByteChannel(pathName, Collections.EMPTY_SET);

        // vérifications
        assertNotNull(res);
        assertEquals(seekableByteChannel, res);
        verify(open).newByteChannel(pathName, Collections.EMPTY_SET);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newByteChannel cas exception")
    void newByteChannelErreurKO() throws IOException {
        PathName pathName = getPathName("abc.txt");
        when(open.newByteChannel(pathName, Collections.EMPTY_SET)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class,
                () -> auditOpen.newByteChannel(pathName, Collections.EMPTY_SET));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newByteChannel(pathName, Collections.EMPTY_SET);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newByteChannel for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    @Test
    @DisplayName("Test newDirectoryStream cas nominal")
    void newDirectoryStreamOK() throws IOException {
        PathName pathName = getPathName("abc.txt");
        DirectoryStream<PathName> directoryStream = mock(DirectoryStream.class);
        DirectoryStream.Filter filter = mock(DirectoryStream.Filter.class);
        when(open.newDirectoryStream(pathName, filter)).thenReturn(directoryStream);

        // methode testée
        DirectoryStream<PathName> res = auditOpen.newDirectoryStream(pathName, filter);

        // vérifications
        assertNotNull(res);
        assertEquals(directoryStream, res);
        verify(open).newDirectoryStream(pathName, filter);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("newDirectoryStream for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertFalse(logMessage.isError());
    }


    @Test
    @DisplayName("Test newDirectoryStream audit désactivé")
    void newDirectoryStreamDisabledFilePattern() throws IOException {
        PathName pathName = getPathName("abc.jpg");
        DirectoryStream<PathName> directoryStream = mock(DirectoryStream.class);
        DirectoryStream.Filter filter = mock(DirectoryStream.Filter.class);
        when(open.newDirectoryStream(pathName, filter)).thenReturn(directoryStream);

        // methode testée
        DirectoryStream<PathName> res = auditOpen.newDirectoryStream(pathName, filter);

        // vérifications
        assertNotNull(res);
        assertEquals(directoryStream, res);
        verify(open).newDirectoryStream(pathName, filter);
        verifyNoMoreInteractions(open);
        assertEquals(0, listLog.size());
    }

    @Test
    @DisplayName("Test newDirectoryStream cas exception")
    void newDirectoryStreamErreurKO() throws IOException {
        PathName pathName = getPathName("abc.txt");
        DirectoryStream.Filter filter = mock(DirectoryStream.Filter.class);
        when(open.newDirectoryStream(pathName, filter)).thenThrow(new IOException("Erreur IO"));

        // methode testée
        IOException res = assertThrows(IOException.class,
                () -> auditOpen.newDirectoryStream(pathName, filter));

        // vérifications
        assertNotNull(res);
        assertEquals("Erreur IO", res.getMessage());
        verify(open).newDirectoryStream(pathName, filter);
        verifyNoMoreInteractions(open);
        assertEquals(1, listLog.size());
        LogMessage logMessage = listLog.get(0);
        assertEquals(AuditLogLevel.INFO, logMessage.getLogLevel());
        assertEquals("Error for newDirectoryStream for file {}", logMessage.getMessage());
        assertEquals(Arrays.asList(pathName), logMessage.getParameters());
        assertTrue(logMessage.isError());
    }

    // methodes utilitaires

    private PathName getPathName(String filename) {
        return new PathName(PATH1, filename);
    }

    @Override
    public void log(AuditLogLevel logLevel, boolean error, String message, Object... parameters) {
        LogMessage logMessage;
        if (parameters != null && parameters.length > 0) {
            logMessage = new LogMessage(logLevel, error, message, Arrays.asList(parameters));
        } else {
            logMessage = new LogMessage(logLevel, error, message, new ArrayList<>());
        }
        listLog.add(logMessage);
    }

    private Map<String, String> defautConfig() {

        Map<String, String> config = new HashMap<>();
        config.put("loglevel", AuditLogLevel.INFO.name());
        //config.put("operations", AuditOperation.NEW_INPUT_STREAM.name());
        config.put("filterPath", "*.txt");
        return config;
    }

}